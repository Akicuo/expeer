package codegen

import (
	"fmt"
	"strings"

	"expeer/pkg/analyzer"
	"expeer/pkg/decompiler"
	"expeer/pkg/disasm"
)

// GenerateC generates C source code from the analysis
func GenerateC(analysis *analyzer.Analysis) string {
	var sb strings.Builder

	// Header comment
	sb.WriteString("/*\n")
	sb.WriteString(" * Decompiled C code - Generated by Expeer\n")
	sb.WriteString(fmt.Sprintf(" * Source binary: %s\n", analysis.Binary.FilePath))
	sb.WriteString(fmt.Sprintf(" * Architecture: %s\n", analysis.Binary.Arch))
	sb.WriteString(fmt.Sprintf(" * Format: %s\n", analysis.Binary.Format))
	sb.WriteString(fmt.Sprintf(" * Confidence: %.2f%%\n", analysis.Confidence*100))
	sb.WriteString(" *\n")
	sb.WriteString(" * WARNING: This is a best-guess reconstruction.\n")
	sb.WriteString(" * The original source code may have been significantly different.\n")
	sb.WriteString(" */\n\n")

	// Standard includes
	sb.WriteString("#include <stdio.h>\n")
	sb.WriteString("#include <stdlib.h>\n")
	sb.WriteString("#include <string.h>\n")
	sb.WriteString("#include <stdint.h>\n\n")

	// Check for specific imports
	hasWinAPI := false
	for _, imp := range analysis.Binary.Imports {
		if strings.Contains(strings.ToLower(imp), "kernel32") ||
			strings.Contains(strings.ToLower(imp), "user32") {
			hasWinAPI = true
			break
		}
	}

	if hasWinAPI {
		sb.WriteString("#ifdef _WIN32\n")
		sb.WriteString("#include <windows.h>\n")
		sb.WriteString("#endif\n\n")
	}

	// Type definitions
	sb.WriteString("/* Type definitions */\n")
	sb.WriteString("typedef unsigned char u8;\n")
	sb.WriteString("typedef unsigned short u16;\n")
	sb.WriteString("typedef unsigned int u32;\n")
	sb.WriteString("typedef unsigned long long u64;\n\n")

	// Forward declarations
	if len(analysis.Functions) > 0 {
		sb.WriteString("/* Forward declarations */\n")
		for _, fn := range analysis.Functions {
			sb.WriteString(fmt.Sprintf("void %s();\n", sanitizeFunctionName(fn.Name)))
		}
		sb.WriteString("\n")
	}

	// String constants (if any found)
	if len(analysis.Strings) > 0 && len(analysis.Strings) < 50 {
		sb.WriteString("/* Extracted strings */\n")
		for i, str := range analysis.Strings {
			if len(str) > 100 {
				str = str[:100] + "..."
			}
			escaped := strings.ReplaceAll(str, "\\", "\\\\")
			escaped = strings.ReplaceAll(escaped, "\"", "\\\"")
			escaped = strings.ReplaceAll(escaped, "\n", "\\n")
			sb.WriteString(fmt.Sprintf("const char* str_%d = \"%s\";\n", i, escaped))
		}
		sb.WriteString("\n")
	}

	// Generate function implementations
	sb.WriteString("/* Function implementations */\n\n")
	for _, fn := range analysis.Functions {
		sb.WriteString(generateCFunction(fn))
		sb.WriteString("\n")
	}

	// Main function hint
	sb.WriteString("/*\n")
	sb.WriteString(" * Entry point (if this is a standalone executable):\n")
	sb.WriteString(" * The actual main() function would be located at the binary's entry point.\n")
	if analysis.Binary.EntryPoint != 0 {
		sb.WriteString(fmt.Sprintf(" * Entry point address: 0x%x\n", analysis.Binary.EntryPoint))
	}
	sb.WriteString(" */\n")

	return sb.String()
}

func generateCFunction(fn disasm.Function) string {
	var sb strings.Builder

	// Decompile the function
	decomp := decompiler.Decompile(fn)
	decompiler.AnalyzeControlFlow(decomp)
	decompiler.InferTypes(decomp)

	funcName := sanitizeFunctionName(fn.Name)

	// Function comment
	sb.WriteString(fmt.Sprintf("/* Function: %s\n", fn.Name))
	sb.WriteString(fmt.Sprintf("   Address: 0x%x - 0x%x\n", fn.StartAddr, fn.EndAddr))
	sb.WriteString(fmt.Sprintf("   Instructions: %d */\n", len(fn.Instructions)))

	// Function signature with inferred return type
	returnType := "void"
	if decomp.HasReturn {
		returnType = "int" // Default assumption
	}

	sb.WriteString(fmt.Sprintf("%s %s(", returnType, funcName))

	// Add parameters if we detected any
	paramCount := 0
	for _, v := range decomp.Variables {
		if v.IsParam {
			if paramCount > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(fmt.Sprintf("%s %s", v.Type, v.Name))
			paramCount++
		}
	}
	if paramCount == 0 {
		sb.WriteString("void")
	}
	sb.WriteString(") {\n")

	// Declare local variables
	if len(decomp.Variables) > 0 {
		sb.WriteString("    /* Local variables */\n")
		for _, v := range decomp.Variables {
			if v.IsLocal && !v.IsParam {
				sb.WriteString(fmt.Sprintf("    %s %s;\n", v.Type, v.Name))
			}
		}
		sb.WriteString("\n")
	}

	// Generate function body from operations
	if len(decomp.Operations) > 0 {
		sb.WriteString("    /* Decompiled code */\n")
		inLoop := false

		for i, op := range decomp.Operations {
			indent := "    "
			if inLoop {
				indent = "        "
			}

			// Check for loop start
			if strings.Contains(op.Comment, "LOOP_START") {
				sb.WriteString(fmt.Sprintf("    while (1) {  // Loop at 0x%x\n", op.Address))
				inLoop = true
			}

			switch op.Type {
			case decompiler.OpAssign:
				if op.Dest != "" && op.Src1 != "" {
					if strings.Contains(op.Src1, "[") {
						// Memory access
						sb.WriteString(fmt.Sprintf("%s%s = *(%s);  // %s\n", indent, op.Dest, op.Src1, op.Comment))
					} else {
						sb.WriteString(fmt.Sprintf("%s%s = %s;\n", indent, op.Dest, op.Src1))
					}
				} else if op.Comment != "" {
					sb.WriteString(fmt.Sprintf("%s// %s\n", indent, op.Comment))
				}

			case decompiler.OpCall:
				funcCall := op.Src1
				if strings.HasPrefix(funcCall, "0x") {
					funcCall = fmt.Sprintf("func_%s", funcCall[2:])
				}
				if op.Dest != "" && op.Dest != "result" {
					sb.WriteString(fmt.Sprintf("%s%s = %s();\n", indent, op.Dest, funcCall))
				} else {
					sb.WriteString(fmt.Sprintf("%s%s();  // %s\n", indent, funcCall, op.Comment))
				}

			case decompiler.OpReturn:
				if inLoop {
					sb.WriteString("    }\n")
					inLoop = false
				}
				if op.Src1 != "" {
					sb.WriteString(fmt.Sprintf("%sreturn %s;\n", indent, op.Src1))
				} else {
					sb.WriteString(fmt.Sprintf("%sreturn;\n", indent))
				}

			case decompiler.OpArithmetic:
				if op.Dest != "" && op.Src1 != "" && op.Src2 != "" {
					cOp := op.Operator
					if cOp == "add" {
						cOp = "+"
					} else if cOp == "sub" {
						cOp = "-"
					} else if cOp == "mul" || cOp == "imul" {
						cOp = "*"
					} else if cOp == "div" || cOp == "idiv" {
						cOp = "/"
					}
					sb.WriteString(fmt.Sprintf("%s%s = %s %s %s;\n", indent, op.Dest, op.Src1, cOp, op.Src2))
				}

			case decompiler.OpCompare:
				// Store comparison for potential if statement
				sb.WriteString(fmt.Sprintf("%s// compare %s with %s\n", indent, op.Src1, op.Src2))

			case decompiler.OpIf:
				condition := "condition"
				if op.Operator == "je" {
					condition = "=="
				} else if op.Operator == "jne" {
					condition = "!="
				} else if op.Operator == "jg" {
					condition = ">"
				} else if op.Operator == "jl" {
					condition = "<"
				}

				// Check if next operation is a backward jump (end of loop)
				if i+1 < len(decomp.Operations) && strings.Contains(op.Src1, "0x") {
					var target uint64
					fmt.Sscanf(op.Src1, "0x%x", &target)
					if target < op.Address && inLoop {
						// Loop condition
						sb.WriteString(fmt.Sprintf("%sif (!(%s)) break;\n", indent, condition))
						continue
					}
				}

				sb.WriteString(fmt.Sprintf("%sif (%s) {  // %s to %s\n", indent, condition, op.Operator, op.Src1))
				sb.WriteString(fmt.Sprintf("%s    // Jump target: %s\n", indent, op.Src1))
				sb.WriteString(fmt.Sprintf("%s}\n", indent))

			default:
				if op.Comment != "" {
					sb.WriteString(fmt.Sprintf("%s// %s\n", indent, op.Comment))
				}
			}
		}

		if inLoop {
			sb.WriteString("    }\n")
		}
	} else {
		sb.WriteString("    // Empty function or no recognizable operations\n")
	}

	sb.WriteString("}\n")

	return sb.String()
}

func sanitizeFunctionName(name string) string {
	// Remove invalid C identifier characters
	name = strings.ReplaceAll(name, ".", "_")
	name = strings.ReplaceAll(name, ":", "_")
	name = strings.ReplaceAll(name, "-", "_")
	name = strings.ReplaceAll(name, " ", "_")

	// Ensure it doesn't start with a number
	if len(name) > 0 && name[0] >= '0' && name[0] <= '9' {
		name = "func_" + name
	}

	if name == "" {
		name = "unknown_func"
	}

	return name
}
