package codegen

import (
	"fmt"
	"strings"

	"expeer/pkg/analyzer"
	"expeer/pkg/decompiler"
	"expeer/pkg/disasm"
)

// GenerateGo generates Go source code from the analysis
func GenerateGo(analysis *analyzer.Analysis) string {
	var sb strings.Builder

	// Package and header comment
	sb.WriteString("package main\n\n")
	sb.WriteString("/*\n")
	sb.WriteString(" * Decompiled Go code - Generated by Expeer\n")
	sb.WriteString(fmt.Sprintf(" * Source binary: %s\n", analysis.Binary.FilePath))
	sb.WriteString(fmt.Sprintf(" * Architecture: %s\n", analysis.Binary.Arch))
	sb.WriteString(fmt.Sprintf(" * Format: %s\n", analysis.Binary.Format))
	sb.WriteString(fmt.Sprintf(" * Confidence: %.2f%%\n", analysis.Confidence*100))
	sb.WriteString(" *\n")
	sb.WriteString(" * WARNING: This is a best-guess reconstruction.\n")
	sb.WriteString(" * The original source code may have been significantly different.\n")
	if len(analysis.GoIndicators) > 0 {
		sb.WriteString(" *\n * Go indicators found:\n")
		for i, indicator := range analysis.GoIndicators {
			if i >= 10 {
				sb.WriteString(fmt.Sprintf(" * ... and %d more\n", len(analysis.GoIndicators)-i))
				break
			}
			sb.WriteString(fmt.Sprintf(" * - %s\n", indicator))
		}
	}
	sb.WriteString(" */\n\n")

	// Imports
	sb.WriteString("import (\n")
	sb.WriteString("\t\"fmt\"\n")

	// Detect common imports from symbols/strings
	hasRuntime := false
	hasOS := false
	hasSync := false

	for _, sym := range analysis.Binary.Symbols {
		name := strings.ToLower(sym.Name)
		if strings.Contains(name, "runtime.") && !hasRuntime {
			hasRuntime = true
		}
		if strings.Contains(name, "os.") && !hasOS {
			hasOS = true
		}
		if strings.Contains(name, "sync.") && !hasSync {
			hasSync = true
		}
	}

	if hasOS {
		sb.WriteString("\t\"os\"\n")
	}
	if hasSync {
		sb.WriteString("\t\"sync\"\n")
	}

	sb.WriteString(")\n\n")

	// Constants from strings
	if len(analysis.Strings) > 0 && len(analysis.Strings) < 50 {
		sb.WriteString("// Extracted string constants\n")
		sb.WriteString("const (\n")
		for i, str := range analysis.Strings {
			if len(str) > 100 {
				str = str[:100] + "..."
			}
			// Escape the string
			escaped := strings.ReplaceAll(str, "\\", "\\\\")
			escaped = strings.ReplaceAll(escaped, "\"", "\\\"")
			escaped = strings.ReplaceAll(escaped, "\n", "\\n")
			sb.WriteString(fmt.Sprintf("\tstr%d = \"%s\"\n", i, escaped))
		}
		sb.WriteString(")\n\n")
	}

	// Type definitions
	sb.WriteString("// Type definitions\n")
	sb.WriteString("type (\n")
	sb.WriteString("\t// Placeholder types - actual types need to be inferred from usage\n")
	sb.WriteString("\tDataStruct struct {\n")
	sb.WriteString("\t\t// Fields unknown\n")
	sb.WriteString("\t}\n")
	sb.WriteString(")\n\n")

	// Generate function implementations
	sb.WriteString("// Function implementations\n\n")

	// Separate main from other functions
	var mainFunc *disasm.Function
	var otherFuncs []disasm.Function

	for i := range analysis.Functions {
		fn := &analysis.Functions[i]
		if strings.Contains(strings.ToLower(fn.Name), "main.main") {
			mainFunc = fn
		} else {
			otherFuncs = append(otherFuncs, *fn)
		}
	}

	// Generate other functions first
	for _, fn := range otherFuncs {
		sb.WriteString(generateGoFunction(fn))
		sb.WriteString("\n")
	}

	// Generate main function last
	if mainFunc != nil {
		sb.WriteString(generateGoFunction(*mainFunc))
	} else {
		// Create a placeholder main
		sb.WriteString("func main() {\n")
		sb.WriteString("\t// Entry point not clearly identified\n")
		sb.WriteString("\t// The actual main function may be obscured or optimized\n")
		if analysis.Binary.EntryPoint != 0 {
			sb.WriteString(fmt.Sprintf("\t// Binary entry point: 0x%x\n", analysis.Binary.EntryPoint))
		}
		sb.WriteString("\tfmt.Println(\"Program execution would start here\")\n")
		sb.WriteString("}\n")
	}

	return sb.String()
}

func generateGoFunction(fn disasm.Function) string {
	var sb strings.Builder

	// Decompile the function
	decomp := decompiler.Decompile(fn)
	decompiler.AnalyzeControlFlow(decomp)
	decompiler.InferTypes(decomp)

	funcName := sanitizeGoFunctionName(fn.Name)

	// Function comment
	sb.WriteString(fmt.Sprintf("// %s - Decompiled function\n", funcName))
	sb.WriteString(fmt.Sprintf("// Address: 0x%x - 0x%x\n", fn.StartAddr, fn.EndAddr))
	sb.WriteString(fmt.Sprintf("// Instructions: %d\n", len(fn.Instructions)))

	// Function signature with parameters and return type
	sb.WriteString(fmt.Sprintf("func %s(", funcName))

	// Add parameters if we detected any
	paramCount := 0
	for _, v := range decomp.Variables {
		if v.IsParam {
			if paramCount > 0 {
				sb.WriteString(", ")
			}
			goType := convertToGoType(v.Type)
			sb.WriteString(fmt.Sprintf("%s %s", v.Name, goType))
			paramCount++
		}
	}

	sb.WriteString(")")

	// Add return type if function returns
	if decomp.HasReturn {
		sb.WriteString(" int") // Default assumption
	}

	sb.WriteString(" {\n")

	// Declare local variables
	if len(decomp.Variables) > 0 {
		sb.WriteString("\t// Local variables\n")
		for _, v := range decomp.Variables {
			if v.IsLocal && !v.IsParam {
				goType := convertToGoType(v.Type)
				sb.WriteString(fmt.Sprintf("\tvar %s %s\n", v.Name, goType))
			}
		}
		sb.WriteString("\n")
	}

	// Generate function body from operations
	if len(decomp.Operations) > 0 {
		sb.WriteString("\t// Decompiled code\n")
		inLoop := false

		for i, op := range decomp.Operations {
			indent := "\t"
			if inLoop {
				indent = "\t\t"
			}

			// Check for loop start
			if strings.Contains(op.Comment, "LOOP_START") {
				sb.WriteString(fmt.Sprintf("\tfor {  // Loop at 0x%x\n", op.Address))
				inLoop = true
			}

			switch op.Type {
			case decompiler.OpAssign:
				if op.Dest != "" && op.Src1 != "" {
					if strings.Contains(op.Src1, "[") {
						// Memory access - use unsafe pointer in comments
						sb.WriteString(fmt.Sprintf("%s%s = /* *(%s) */ 0  // %s\n", indent, op.Dest, op.Src1, op.Comment))
					} else {
						// Try to parse numeric values
						sb.WriteString(fmt.Sprintf("%s%s = %s\n", indent, op.Dest, op.Src1))
					}
				} else if op.Comment != "" {
					sb.WriteString(fmt.Sprintf("%s// %s\n", indent, op.Comment))
				}

			case decompiler.OpCall:
				funcCall := op.Src1
				if strings.HasPrefix(funcCall, "0x") {
					funcCall = fmt.Sprintf("func_%s", funcCall[2:])
				}
				if op.Dest != "" && op.Dest != "result" {
					sb.WriteString(fmt.Sprintf("%s%s = %s()\n", indent, op.Dest, funcCall))
				} else {
					sb.WriteString(fmt.Sprintf("%s%s()  // %s\n", indent, funcCall, op.Comment))
				}

			case decompiler.OpReturn:
				if inLoop {
					sb.WriteString("\t}\n")
					inLoop = false
				}
				if op.Src1 != "" {
					sb.WriteString(fmt.Sprintf("%sreturn %s\n", indent, op.Src1))
				} else {
					sb.WriteString(fmt.Sprintf("%sreturn\n", indent))
				}

			case decompiler.OpArithmetic:
				if op.Dest != "" && op.Src1 != "" && op.Src2 != "" {
					goOp := op.Operator
					if goOp == "add" {
						goOp = "+"
					} else if goOp == "sub" {
						goOp = "-"
					} else if goOp == "mul" || goOp == "imul" {
						goOp = "*"
					} else if goOp == "div" || goOp == "idiv" {
						goOp = "/"
					}
					sb.WriteString(fmt.Sprintf("%s%s = %s %s %s\n", indent, op.Dest, op.Src1, goOp, op.Src2))
				}

			case decompiler.OpCompare:
				// Store comparison for potential if statement
				sb.WriteString(fmt.Sprintf("%s// compare %s with %s\n", indent, op.Src1, op.Src2))

			case decompiler.OpIf:
				condition := "condition"
				if op.Operator == "je" {
					condition = "=="
				} else if op.Operator == "jne" {
					condition = "!="
				} else if op.Operator == "jg" {
					condition = ">"
				} else if op.Operator == "jl" {
					condition = "<"
				}

				// Check if next operation is a backward jump (end of loop)
				if i+1 < len(decomp.Operations) && strings.Contains(op.Src1, "0x") {
					var target uint64
					fmt.Sscanf(op.Src1, "0x%x", &target)
					if target < op.Address && inLoop {
						// Loop condition
						sb.WriteString(fmt.Sprintf("%sif !(%s) {\n", indent, condition))
						sb.WriteString(fmt.Sprintf("%s\tbreak\n", indent))
						sb.WriteString(fmt.Sprintf("%s}\n", indent))
						continue
					}
				}

				sb.WriteString(fmt.Sprintf("%sif %s {  // %s to %s\n", indent, condition, op.Operator, op.Src1))
				sb.WriteString(fmt.Sprintf("%s\t// Jump target: %s\n", indent, op.Src1))
				sb.WriteString(fmt.Sprintf("%s}\n", indent))

			default:
				if op.Comment != "" {
					sb.WriteString(fmt.Sprintf("%s// %s\n", indent, op.Comment))
				}
			}
		}

		if inLoop {
			sb.WriteString("\t}\n")
		}
	} else {
		sb.WriteString("\t// Empty function or no recognizable operations\n")
	}

	sb.WriteString("}\n")

	return sb.String()
}

func convertToGoType(cType string) string {
	switch cType {
	case "int":
		return "int"
	case "void*":
		return "uintptr"
	case "char*":
		return "string"
	default:
		return "interface{}"
	}
}

func sanitizeGoFunctionName(name string) string {
	// Handle Go-specific name mangling
	name = strings.TrimPrefix(name, "main.")
	name = strings.TrimPrefix(name, "runtime.")

	// Remove package paths
	if idx := strings.LastIndex(name, "."); idx >= 0 {
		name = name[idx+1:]
	}

	// Replace invalid characters
	name = strings.ReplaceAll(name, ".", "_")
	name = strings.ReplaceAll(name, ":", "_")
	name = strings.ReplaceAll(name, "-", "_")
	name = strings.ReplaceAll(name, " ", "_")
	name = strings.ReplaceAll(name, "*", "Ptr")
	name = strings.ReplaceAll(name, "[", "_")
	name = strings.ReplaceAll(name, "]", "_")
	name = strings.ReplaceAll(name, "(", "_")
	name = strings.ReplaceAll(name, ")", "_")

	// Ensure it starts with uppercase (exported) or lowercase
	if len(name) > 0 {
		if name[0] >= 'a' && name[0] <= 'z' {
			// Keep lowercase
		} else if name[0] >= 'A' && name[0] <= 'Z' {
			// Keep uppercase
		} else {
			name = "func_" + name
		}
	}

	if name == "" {
		name = "unknownFunc"
	}

	return name
}
